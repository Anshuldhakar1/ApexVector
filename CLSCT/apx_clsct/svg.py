"""SVG path generation module."""

from typing import List, Tuple

import numpy as np

from .types import Contour, Color, SVGError


def contours_to_svg(
    layers: List[Tuple[Color, List[Contour]]],
    width: int,
    height: int,
    smooth: bool = True
) -> str:
    """Convert smoothed contours to SVG.
    
    Converts the smoothed curve points into SVG path commands
    (M, L, C, Q, Z). Each color layer becomes an SVG <path>
    element with a solid fill.
    
    Args:
        layers: List of (color, contours) tuples
        width: Image width
        height: Image height
        smooth: If True, use cubic bezier curves; else use lines
        
    Returns:
        SVG string containing vectorized image
        
    Raises:
        SVGError: If SVG generation fails
    """
    try:
        svg_parts = [
            f'<svg xmlns="http://www.w3.org/2000/svg" width="{width}" height="{height}" viewBox="0 0 {width} {height}">',
            '<!-- Generated by apx-clsct -->'
        ]
        
        for color, contours in layers:
            # Convert color to hex
            color_hex = color_to_hex(color)
            
            for contour in contours:
                if len(contour) < 3:
                    continue
                
                if smooth:
                    path_data = contour_to_bezier_path(contour)
                else:
                    path_data = contour_to_line_path(contour)
                
                svg_parts.append(
                    f'  <path d="{path_data}" fill="{color_hex}" stroke="none" />'
                )
        
        svg_parts.append('</svg>')
        return '\n'.join(svg_parts)
        
    except Exception as e:
        raise SVGError(f"SVG generation failed: {e}") from e


def color_to_hex(color: Color) -> str:
    """Convert color tuple to hex string.
    
    Args:
        color: RGB or RGBA tuple
        
    Returns:
        Hex color string (e.g., "#FF0000")
    """
    if len(color) == 4:
        # RGBA - ignore alpha for now or use it
        r, g, b, _ = color
    else:
        r, g, b = color
    
    return f"#{int(r):02X}{int(g):02X}{int(b):02X}"


def contour_to_line_path(contour: Contour) -> str:
    """Convert contour to SVG path using line commands.
    
    Args:
        contour: Array of (x, y) points
        
    Returns:
        SVG path data string
    """
    if len(contour) == 0:
        return ""
    
    parts = [f"M {contour[0][0]:.2f} {contour[0][1]:.2f}"]
    
    for point in contour[1:]:
        parts.append(f"L {point[0]:.2f} {point[1]:.2f}")
    
    parts.append("Z")
    return " ".join(parts)


def contour_to_bezier_path(contour: Contour) -> str:
    """Convert contour to smooth SVG path using cubic bezier.
    
    Uses a simple smoothing approach where each segment is
    approximated with cubic bezier curves.
    
    Args:
        contour: Array of (x, y) points
        
    Returns:
        SVG path data string with cubic bezier commands
    """
    if len(contour) < 3:
        return contour_to_line_path(contour)
    
    # Calculate control points for smooth curves
    points = np.array(contour)
    n = len(points)
    
    parts = [f"M {points[0][0]:.2f} {points[0][1]:.2f}"]
    
    for i in range(n):
        # Current point and next point
        p0 = points[i]
        p1 = points[(i + 1) % n]
        
        # Previous and next for calculating control points
        p_prev = points[(i - 1) % n]
        p_next = points[(i + 2) % n]
        
        # Calculate control points (Catmull-Rom-like)
        # Control point 1: based on vector from p_prev to p1
        cp1 = p0 + (p1 - p_prev) * 0.2
        
        # Control point 2: based on vector from p0 to p_next
        cp2 = p1 - (p_next - p0) * 0.2
        
        parts.append(
            f"C {cp1[0]:.2f} {cp1[1]:.2f}, "
            f"{cp2[0]:.2f} {cp2[1]:.2f}, "
            f"{p1[0]:.2f} {p1[1]:.2f}"
        )
    
    parts.append("Z")
    return " ".join(parts)


def save_svg(svg_string: str, output_path: str) -> None:
    """Save SVG string to file.
    
    Args:
        svg_string: SVG content
        output_path: Path to save file
    """
    with open(output_path, 'w') as f:
        f.write(svg_string)
